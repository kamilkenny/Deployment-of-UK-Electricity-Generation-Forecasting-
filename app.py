# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YshZ0vTLJq1lwolpQ2IM26F1TUqQ607-
"""

import streamlit as st
import pandas as pd
import joblib
import datetime
import numpy as np
import matplotlib.pyplot as plt

# 1. Page Configuration
st.set_page_config(page_title="UK Grid Analytics | Kamil Kehinde", layout="wide")

# 2. Optimized Data & Model Loading
@st.cache_resource
def load_assets():
    # Load Model
    model = joblib.load('gb_gen_time_only.pkl')
    # Load sliced CSV (October 2025 - Feb 14, 2026)
    try:
        # Optimized: Load only the columns we actually need
        hist_data = pd.read_csv('TOTAL DEMAND GB.csv', usecols=['settlement_date', 'actual_mw'])
        # Handle the 'T' format timestamp
        hist_data['settlement_date'] = pd.to_datetime(hist_data['settlement_date'])
    except Exception as e:
        st.sidebar.error(f"Data Load Error: {e}")
        hist_data = pd.DataFrame()
    return model, hist_data

model, validation_df = load_assets()

# 3. Sidebar
with st.sidebar:
    st.header("ðŸ‘¤ Lead Modeller")
    st.write("**Kamil Kehinde**")
    st.divider()
    st.info("Validation Window: Oct 1, 2025 â€“ Feb 14, 2026")

# 4. Main Dashboard
st.title("âš¡ UK Electricity Generation Dashboard")

# Date Input (Includes validation range)
selected_range = st.date_input(
    "Select Analysis Range",
    value=(datetime.date(2026, 2, 10), datetime.date(2026, 2, 17))
)

if st.button("ðŸš€ Run Analysis", use_container_width=True):
    if len(selected_range) == 2:
        start_d, end_d = selected_range

        # Create full half-hourly index for the selected range
        idx = pd.date_range(
            start=datetime.datetime.combine(start_d, datetime.time(0, 0)),
            end=datetime.datetime.combine(end_d, datetime.time(23, 30)),
            freq='30min'
        )

        # Feature Engineering for Prediction
        df_final = pd.DataFrame(index=idx)
        df_final['hour'] = df_final.index.hour
        df_final['dayofweek'] = df_final.index.dayofweek
        df_final['month'] = df_final.index.month
        df_final['year'] = df_final.index.year

        # Predict Generation
        df_final['Forecast_MW'] = model.predict(df_final)
        df_final = df_final.reset_index().rename(columns={'index': 'timestamp'})

        # 5. Conditional Residual Logic
        if not validation_df.empty:
            # Match forecast with actuals from Oct 2025 CSV
            df_final = pd.merge(
                df_final,
                validation_df,
                left_on='timestamp',
                right_on='settlement_date',
                how='left'
            )
            # Calculate Residuals only where past data exists
            df_final['Residual_MW'] = df_final['actual_mw'] - df_final['Forecast_MW']
        else:
            df_final['actual_mw'] = np.nan
            df_final['Residual_MW'] = np.nan

        # 6. Display Performance Metrics
        m1, m2 = st.columns(2)
        m1.metric("Peak Forecasted Load", f"{df_final['Forecast_MW'].max():,.0f} MW")

        # Check if any part of the selection has validation data
        has_actuals = df_final['actual_mw'].notnull().any()
        if has_actuals:
            mae = df_final['Residual_MW'].abs().mean()
            m2.metric("Mean Absolute Error (MAE)", f"{mae:,.0f} MW", delta_color="inverse")
        else:
            m2.info("Future Forecast Only (Residuals hidden)")

        # 7. Visualization
        st.subheader("ðŸ“Š Generation Trends & Residual Variance")
        fig, ax = plt.subplots(figsize=(10, 4))
        ax.plot(df_final['timestamp'], df_final['Forecast_MW'], label='Predicted Generation', color='#007acc', linewidth=2)

        if has_actuals:
            # Scatter plot actuals to highlight gaps/residuals
            ax.scatter(df_final['timestamp'], df_final['actual_mw'], label='Actual Generation (Past)', color='orange', s=8, alpha=0.6)
            ax.fill_between(df_final['timestamp'], df_final['Forecast_MW'], df_final['actual_mw'], color='red', alpha=0.1, label='Model Residual')

        plt.xticks(rotation=45)
        ax.legend()
        st.pyplot(fig)

        # 8. Data Export
        st.download_button("ðŸ“¥ Export CSV Report", df_final.to_csv(index=False), "grid_validation_export.csv")